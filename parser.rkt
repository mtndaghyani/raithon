#lang racket
(require "lexer.rkt")

(require parser-tools/lex
         (prefix-in : parser-tools/lex-sre)
         parser-tools/yacc)

(define raithon-parser
           (parser
            (start program)
            (end EOF)
            (error void)
            (tokens literals operators keywords seperators)
            (grammar
             (program ((stmts) $1))
             (stmts ((stmt SEMI) (list $1))
                    ((stmt SEMI stmts) (cons $1 $3)))
             (stmt ((compound_stmt) $1)
                   ((simple_stmt) $1))
             (simple_stmt ((assignment) $1)
                          ((return_stmt) $1)
                          ((global_stmt) $1)
                          ((PASS) (list 'pass))
                          ((BREAK) (list 'break))
                          ((CONTINUE) (list 'continue)))
             (compound_stmt ((function_def) $1)
                            ((if_stmt) $1)
                            ((for_stmt) $1))
             (assignment ((ID EQUAL expression) (list 'assign $1 $3)))
             (return_stmt ((RETURN) (list 'return))
                          ((RETURN expression) (list 'return $2)))
             (global_stmt ((GLOBAL ID) (list 'global $2)))
             (function_def ((DEF ID LPAR params RPAR COLON stmts) (list 'proc $2 $4 $7))
                           ((DEF ID LPAR RPAR COLON stmts) (list 'proc $2 '() $6)))
             (params ((param_with_default) (list $1))
                     ((param_with_default COMMA params) (cons $1 $3)))
             (param_with_default ((ID EQUAL expression) (list 'default_param $1 $3)))
             (if_stmt ((IF expression COLON stmts ELSE COLON stmts) (list 'if $2 $4 $7)))
             (for_stmt ((FOR ID IN expression COLON stmts) (list 'for $2 $4 $6)))
             (expression ((disjunction) $1))
             (disjunction ((conjunction) $1)
                          ((disjunction OR conjunction) (list 'or $1 $3)))
             (conjunction ((inversion) $1)
                          ((conjunction AND inversion) (list 'and $1 $3)))
             (inversion ((NOT inversion) (list 'not $2))
                        ((comparison) $1))
             (comparison ((sum compare_op_sum_pairs) (list 'comparison $1 $2))
                         ((sum) $1)) ;?
             (compare_op_sum_pairs ((compare_op_sum_pair) (list $1))
                                   ((compare_op_sum_pair compare_op_sum_pairs) (cons $1 $2)))
             (compare_op_sum_pair ((eq_sum) $1)
                                  ((lt_sum) $1)
                                  ((gt_sum) $1))
             (eq_sum ((EQEQUAL sum) (list 'equal $2)))
             (lt_sum ((LESS sum) (list 'less $2)))
             (gt_sum ((MORE sum) (list 'more $2)))
             (sum ((sum PLUS term) (list 'plus $1 $3))
                  ((sum MINUS term) (list 'minus $1 $3))
                  ((term) $1))
             (term ((term STAR factor) (list 'star $1 $3))
                   ((term SLASH factor) (list 'slash $1 $3))
                   ((factor) $1))
             (factor ((PLUS factor) (list 'plus $2))
                     ((MINUS factor) (list 'minus $2))
                     ((power) $1))
             (power ((atom DOUBLESTAR factor) (list 'doublestar $1 $3))
                    ((primary) $1))
             (primary ((atom) $1)
                      ((primary LSQB expression RSQB) (list 'index $1 $3))
                      ((primary LPAR RPAR) (list 'call $1 '()))
                      ((primary LPAR arguments RPAR) (list 'call $1 $3)))
             (arguments ((expression) (list $1))
                        ((expression COMMA arguments) (cons $1 $3)))
             (atom ((ID) (list 'var $1))
                   ((TRUE) (list 'true))
                   ((FALSE) (list 'false))
                   ((NONE) (list 'none))
                   ((NUMBER) (list 'num $1))
                   ((lst) $1))
             (lst ((LSQB expressions RSQB) ((list 'list $2)))
                  ((LSQB RSQB) (list 'list '())))
             (expressions ((expression) (list $1))
                          ((expression COMMA expressions) (cons $1 $3)))
             
             )))

;test
(define lex-this (lambda (lexer input) (lambda () (lexer input))))
(define my-lexer (lex-this raithon-lexer (open-input-string "global x; pass; break; continue; if x == 2: return 0; else: return 1;; a = b or c and 2 + 3 ** 4 - 1 > 0;")))
(let ((parser-res (raithon-parser my-lexer))) parser-res)

